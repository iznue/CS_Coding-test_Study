# Data Structure
- 연산에 사용되는 컴퓨터의 메모리 자원은 한정적인데 반해 처리할 데이터는 무수히 많음. 이 메모리 공간을 효율적으로 사용해야 하는데 필요한 것이 자료구조 !
- **자료에 효율적으로 접근하고 수정할 수 있도록 데이터를 구성하고 저장하는 방법** 
- 자료 구조의 선택 -> 효율적인 알고리즘의 선택 => 자료구조 + 알고리즘(+a) = 프로그램
- 저장 형태에 따라 **선형 자료구조** & **비선형 자료구조**로 구분
    - 선형 자료구조 : 데이터가 일렬로 나열됨 (**array, linked list, stack, queue...**)
    - 비선형 자료구조 : 데이터가 특정한 형태를 띔 (**tree, graph...**)

![자료구조 실행시간](./img/datastructure_timecomplexity.png)

---
## Array (배열)
- 동일한 타입의 데이터들을 저장하며, 고정된 크기를 가짐
- 인덱스 번호로 데이터에 접근 가능 (random access 가능)
- 데이터 삽입 / 삭제가 어려움 (shift 해야함)
  
&rarr; 배열 목록, 힙, 해시 테이블, 벡터 및 행렬과 같은 기타 데이터 구조를 구축하기 위한 빌딩 블록

&rarr; **삽입 정렬, 버블 정렬, 병합 정렬 등 다양한 정렬 알고리즘에 사용**

> #### 시간복잡도 & 공간복잡도
> - 데이터 조회 : 0(1)
> - 데이터 삽입 / 삭제 : 0(n)

---
## Linked List (연결 리스트)
- 각 데이터 시퀀스가 순서를 가지고 연결된 순차적 구조 / 각 노드가 데이터와 포인터를 가짐
- 데이터 접근이 느림 (링크를 타고 찾아야 함)
- 동적인 데이터 추가 / 삭제에 유리 but 포인터를 위한 추가 공간이 필요
- 각 요소 : Node &rarr; Node에는 key와 다음 포인터인 next 포함
- 첫 번째 요소 : Head / 마지막 요소 : Tail

![연결리스트](./img/linkedlist.png)

> #### 시간복잡도 & 공간복잡도
> - 데이터 조회 : 0(n)
> - **맨 앞/뒤** 데이터 삽입/삭제 : 0(1) &rarr; SinglyLinkedList의 경우 맨 뒤 데이터 삭제 연산은 0(n)
> - **중간의 원하는 위치** 데이터 삽입 삭제 : 0(n) &rarr; 원하는 원소까지 데이터를 조회하는 과정이 있으므로 0(n) + 0(1)

### Array vs LinkedList
- 데이터 접근 속도
     - Array는 인덱스를 통한 random access 지원 &rarr; 시간 복잡도 0(1)로 빠르게 접근 가능
     - LinkedList는 순차 접근 방식 사용 &rarr; 시간 복잡도 0(n)
- 데이터 삽입 & 삭제 속도
     - Array는 데이터를 중간 or 맨 앞에 삽입/삭제하는 경우 shift가 필요해 데이터가 많아질수록 비효율적
     - LinkedList는 중간 삽입/삭제는 0(n)의 시간 복잡도를 갖지만, 맨 앞/뒤에 삽입하는 경우 0(1)의 시간복잡도를 가짐
     - but LinkedList는 데이터 삽입/삭제마다 메모리 할당 & 해제가 일어나 시간복잡도는 빨라도 System call
- 메모리 할당
     - Array는 정적 메모리 할당 (compile time)
     - LinkedList는 동적 메모리 할당 (runtime)
     - Array는 데이터 삽입 시 모든 공간이 다 차면 새로운 메모리 공간이 필요하지만 LinkedList는 동적으로 할당받음

&rarr; **데이터 삽입/삭제가 빈번하면 LinkedList, 데이터 접근 속도가 중요하면 Array 사용 권장**

---
## Stack
- 순서가 보존되는 선형 데이터 구조, 삽입/삭제 연산이 한 방향에서 이루어짐
- 가장 마지막 요소(최근요소)부터 처리하는 LIFO(Last In First Out)

#### 주요 연산
- 'push' : 스택의 top에 원소 삽입
- 'pop' : 스택의 top에 있는 원소 삭제 및 반환
- 'peek' : 스택의 top에 있는 원소 반환

> #### 시간복잡도 & 공간복잡도
> - top 데이터 조회 : 0(1)
> - 특정 데이터 조회 : 0(n)
> - 데이터 삽입/삭제 : 0(1)

### Stack 활용
- system stack / runtime stack : 프로그램 함수 호출과 복귀에 따른 실행 순서 관리
- interrupt routine 처리
- 수식의 후위 표기법 (postfix notation)
- 계산기 검사
- 깊이 우선 탐색 (DFS)

> **프로그램의 함수 호출과 복귀에 따른 실행 순서 관리 과정**
> 1. 함수 호출 발생 시 stack frame에 지역변수, 매개변수, 수행 후 복귀할 주소 등의 정보를 저장해 시스템 스택에 삽입
> 2. 함수 실행이 끝나면 시스템 스택의 top에 있는 stack frame 원소를 pop, frame에 저장된 복귀 주소를 확인하고 복귀
> 3. 함수 호출 - 복귀에 따라 해당 과정을 반복, 전체 프로그램 수행 종료 시 시스템 스택은 공백 스택이 됨
&rarr; 함수 호출은 가장 마지막에 호출된 함수가 가장 먼저 실행 완료하고 복귀하는 후입선출 구조이므로 스택을 이용해 관리 !

--- 
## Queue
- 한 방향에서는 삽입 / 반대 방향에서는 삭제연산이 이루어지는 선형 자료구조
- **FIFO(First in first out) : 먼저 들어간 원소가 먼저 나옴**

#### 주요 함수
- 'push' : 데이터 추가
- 'pop' : queue의 front 데이터 삭제
- 'front' : 제일 최상위 데이터 반환
- 'back' : 제일 마지막 데이터 반환
- 'size' : queue의 현재 사이즈 반환
- 'empty' : 비어있는지 확인
- 'swap' : 두 queue의 내용 바꾸기

> #### 시간복잡도 & 공간복잡도
> - front 데이터 조회 : 0(1)
> - 특정 데이터 조회 : 0(n)
> - 데이터 삽입/삭제 : 0(1)

### Queue 활용
- 프로세스 레디 큐
- 스케쥴링
- 캐시 구현
- 너비 우선 탐색 (BFS)

## Priority Queue
- 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나옴
- 값을 비교해야 하므로 null을 허용하지 않음
- 내부는 이진트리 힙으로 구성됨

#### 주요 기능
- 'enqueue' : queue에 새 요소 삽입
- 'dequeue' : queue에서 최대 우선 순위 요소를 삭제하고 해당 값 반환
- 'peek' : queue에서 최대 우선순위 요소 반환

> 1. 모든 항목에는 우선순위가 존재
> 2. 우선순위가 높은 요소는 우선 순위가 낮은 요소보다 먼저 queue에서 제외
> 3. 두 요소의 우선 순위가 같으면 queue의 순서에 따라 제공

#### Priority Queue 구현
- 배열, 연결리스트, 힙으로 구현 가능
- **Heap이 최악의 경우에도 0(log n)을 보장**하므로 보통 힙으로 구현함

## Stack ↔ Queue 구현
- stack은 LIFO, queue는 FIFO이므로 들어오고 나갈 떄 저장된 순서를 뒤집으면 서로간에 구현이 가능함

#### Stack &rarr; Queue
- 뺄 때 다른 스택으로 옮겨서 빼기 !
- enqueue : a stack에 push / dequeue : b 스택에 남은게 있다면 b에 있는 것을 pop, 없다면 a 스택에 있는 것을 모두 pop해서 b로 push하고 b에 있는 것을 pop

[stack_to_queue](./code/Stack/stack_to_queue.cpp)

#### Queue &rarr; Stack
- 넣어줄 때 순서를 바꿔서 넣기 !
- push : main queue에 데이터가 있다면 모두 dequeue해서 sub queue로 넣음. 그 후 main queue에 삽입하려는 데이터를 삽입하고, sub queue로 옮겨 놓은 것을 모두 dequeue해서 main queue로 넣음
- pop : main queue에 있는 것을 dequeue함

[queue_to_stack](./code/Queue/queue_to_stack.cpp)

---
## Tree
- 자료들 간의 계층적 관계를 나타내는데 사용하는 자료 구조 &rarr; 부모-자식 관계로 표현
- 비선형 자료 구조
> 루트 노드가 존재함 (트리는 반드시 1개 이상의 노드를 가짐)
> 트리의 부분 트리 또한 트리 구조를 따름

#### 용어
> - 루트 노드 : 최상위 노드, unique함
> - 부모 노드 : 부모-자식 관계에서 상위 계층
> - 자식 노드 : 부모-자식 관계에서 하위 계층
> - 형제 노드 : 부모가 동일한 노드
> - 조상 노드 : 해당 노드의 부모 노드 ~ 루트 노드까지의 경로에 존재하는 모드 노드
> - 후손 노드 : 해당 노드를 루트로 하는 부분 트리의 모든 노드
> - 내부 노드 : 자식이 있는 노드 / 외부 노드 : 자식이 없는 노드
> - 깊이 : 루트 노드에서 해당 노드까지 도달하는데 사용하는 간선 수 &rarr; 루트 노드 깊이는 0
> - 레벨 : 노드의 깊이 + 1
> - 높이 : 루트 노드에서 해당 노드까지 도달하는데 지나간 정점 수 &rarr; 트리의 높이 = 해당 트리 내 모든 노드의 높이 중 최댓값
> - 차수 : 노드의 자식 수 &rarr; 트리의 차수 = 해당 트리 내 모든 노드의 차수 중 최댓값

> #### 시간복잡도 & 공간복잡도
> - 노드 검색 : 0(n)
> - 노드 삽입/삭제 : 0(1)
>         - 노드 삭제의 경우 언어와 구현에 따라 시간복잡도가 달라짐

### Tree 활용
- 파일 시스템
- 검색 엔진
- 트라이 알고리즘

## Indexed Tree = Segment Tree
- 순서를 갖는 정보가 주어질 때, **구간의 대표 값이나 연산 결과**를 빠르게 얻는 자료구조
- **구간 합, 구간 내 최댓값, 구간 내 카운트** 등을 구할 때 사용
- segment tree는 indexed tree가 포함하고 있는 한 종류임

> #### Top-Down 방식 구현 (DFS 기반 : 재귀호출)
> - 왼쪽 자식 = 2*node, 오른쪽 자식 = 2*node + 1
> - 가지치기 가능 (더 이상 탐색하지 않아도 되는 곳은 가지 않음)
> - x번째로 빠른 숫자 등 카운팅 쿼리 가능

> #### Bottom-Up 방식 구현 (반복문 기반 트리 탐색)
> - 인덱스의 홀짝 특성 이용
> - 부모 노드 = node / 2
> - 코드가 더 단순하며, 수행 속도가 상대적으로 빠름

---
## Binary Tree
- 트리의 차수가 2 이하인 트리
- 비선형 자료구조
- 자식이 최대 2개이므로 왼쪽, 오른쪽 자식으로 구분함 / 일반 트리는 0개의 노드를 가질 수 없으나, 공백 이진 트리는 존재함
- **레벨 i에서의 최대 노드 수 : 2<sup>(i-1)</sup>**
- **깊이가 k**인 이진 트리의 최대 노드 수 :**2<sup>k</sup>-1**
- **n0= n2 + 1** (리프 노드의 수 = 자식 노드가 2개인 노드의 수 + 1)

#### 이진 트리의 표현
> 1. 배열 표현
> - i가 1이 아니면 parent(i)는 [i/2]에 위치. 만약 i가 1이면 루트이므로 부모가 없음
> - 2i <= n 이면 leftchild(i)는 2i에 위치. 만약 2i > n이면 i는 왼쪽 자식이 없음
> - 2i + 1 <= n 이면 rightchild(i)는 2i + 1에 위치. 만약 2i + 1 > n이면 i는 오른쪽 자식
> - **완전 이진트리일 때 이상적 표현이 가능하지만 편향된트리인 경우 공간 낭비가 발생, 중간에 노드 삽입/삭제 시 위치 변경이 일어남**
> - 이를 극복하기 위해 **연결 표현** 사용 가능
>
> 2. 연결 표현
> - 각 노드를 leftchild, rightchild를 가지는 구조체로 만들어 표현
> - **공간 낭비 최소화, 삽입/삭제 시 비용이 발생하는 순차 표현의 문제 해소**
> - but 부모 노드 파악이 어려움 &rarr; 이를 위해 data, leftchild, rightchild에 더해 4번째 필드 값으로 parent 추가 가능

### 이진 탐색 트리 (Binary Search Tree)
- 이진탐색 + 연결리스트를 결합한 이진트리
- 이진 탐색의 효율적인 탐색 능력은 유지하되 빈번한 자료 입려/삭제가 가능하게 고안됨
> 특징
> - 각 노드에 중복되지 않은 키가 있음
> - 루트 노드의 왼쪽 서브 트리는 해당 노드 키보다 작은 키를 갖는 노드로 이루어짐
> - 루트 노드의 오른쪽 서브 트리는 해당 노드 키보다 큰 키를 갖느 노드로 이루어짐
> - 좌우 서브트리도 모두 이진 탐색 트리어야 함
&rarr; **이진 탐색 트리는 모든 왼쪽 자식 값이 루트나 부모보다 작고, 모든 오른쪽 자식이 루트나 부모보다 큰 값을 가짐**

> #### 시간복잡도 & 공간복잡도
> - 연결리스트 : 삽입/삭제 &rarr; 0(1) / 탐색 &rarr; 0(n)
> - 이진 탐색 : 0(log n), but 삽입/삭제 불가능
> - 이진 탐색 트리 : 0(log n), 삽입/삭제 가능

[binary_tree_detail](./Binary_tree.md)

---






