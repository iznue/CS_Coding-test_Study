# Data Structure
- 연산에 사용되는 컴퓨터의 메모리 자원은 한정적인데 반해 처리할 데이터는 무수히 많음. 이 메모리 공간을 효율적으로 사용해야 하는데 필요한 것이 자료구조 !
- **자료에 효율적으로 접근하고 수정할 수 있도록 데이터를 구성하고 저장하는 방법** 
- 자료 구조의 선택 -> 효율적인 알고리즘의 선택 => 자료구조 + 알고리즘(+a) = 프로그램
- 저장 형태에 따라 **선형 자료구조** & **비선형 자료구조**로 구분
    - 선형 자료구조 : 데이터가 일렬로 나열됨 (**array, linked list, stack, queue...**)
    - 비선형 자료구조 : 데이터가 특정한 형태를 띔 (**tree, graph...**)

![자료구조 실행시간](./img/datastructure_timecomplexity.png)

---
## Array (배열)
- 동일한 타입의 데이터들을 저장하며, 고정된 크기를 가짐
- 인덱스 번호로 데이터에 접근 가능 (random access 가능)
- 데이터 삽입 / 삭제가 어려움 (shift 해야함)
  
&rarr; 배열 목록, 힙, 해시 테이블, 벡터 및 행렬과 같은 기타 데이터 구조를 구축하기 위한 빌딩 블록

&rarr; **삽입 정렬, 버블 정렬, 병합 정렬 등 다양한 정렬 알고리즘에 사용**

> #### 시간복잡도 & 공간복잡도
> - 데이터 조회 : 0(1)
> - 데이터 삽입 / 삭제 : 0(n)

---
## Linked List (연결 리스트)
- 각 데이터 시뭔스가 순서를 가지고 연결된 순차적 구조
- 데이터 접근이 느림 (링크를 타고 찾아야 함)
- 동적인 데이터 추가 / 삭제에 유리 but 포인터를 위한 추가 공간이 필요
- 각 요소 : Node &rarr; Node에는 key와 다음 포인터인 next 포함
- 첫 번째 요소 : Head / 마지막 요소 : Tail

![연결리스트](./img/linkedlist.png)

> #### 시간복잡도 & 공간복잡도
> - 데이터 조회 : 0(n)
> - **맨 앞/뒤** 데이터 삽입/삭제 : 0(1) &rarr; SinglyLinkedList의 경우 맨 뒤 데이터 삭제 연산은 0(n)
> - **중간의 원하는 위치** 데이터 삽입 삭제 : 0(n) &rarr; 원하는 원소까지 데이터를 조회하는 과정이 있으므로 0(n) + 0(1)

### Array vs LinkedList
- 데이터 접근 속도
     - Array는 인덱스를 통한 random access 지원 &rarr; 시간 복잡도 0(1)로 빠르게 접근 가능
     - LinkedList는 순차 접근 방식 사용 &rarr; 시간 복잡도 0(n)
- 데이터 삽입 & 삭제 속도
     - Array는 데이터를 중간 or 맨 앞에 삽입/삭제하는 경우 shift가 필요해 데이터가 많아질수록 비효율적
     - LinkedList는 중간 삽입/삭제는 0(n)의 시간 복잡도를 갖지만, 맨 앞/뒤에 삽입하는 경우 0(1)의 시간복잡도를 가짐
     - but LinkedList는 데이터 삽입/삭제마다 메모리 할당 & 해제가 일어나 시간복잡도는 빨라도 System call
- 메모리 할당
     - Array는 정적 메모리 할당 (compile time)
     - LinkedList는 동적 메모리 할당 (runtime)
     - Array는 데이터 삽입 시 모든 공간이 다 차면 새로운 메모리 공간이 필요하지만 LinkedList는 동적으로 할당받음

&rarr; **데이터 삽입/삭제가 빈번하면 LinkedList, 데이터 접근 속도가 중요하면 Array 사용 권장**

---
## Stack
- 순서가 보존되는 선형 데이터 구조, 삽입/삭제 연산이 한 방향에서 이루어짐
- 가장 마지막 요소(최근요소)부터 처리하는 LIFO(Last In First Out)

#### 주요 연산
- 'push' : 스택의 top에 원소 삽입
- 'pop' : 스택의 top에 있는 원소 삭제 및 반환
- 'peek' : 스택의 top에 있는 원소 반환

> #### 시간복잡도 & 공간복잡도
> - top 데이터 조회 : 0(1)
> - 특정 데이터 조회 : 0(n)
> - 데이터 삽입/삭제 : 0(1)

### Stack 활용
- system stack / runtime stack : 프로그램 함수 호출과 복귀에 따른 실행 순서 관리
- interrupt routine 처리
- 수식의 후위 표기법 (postfix notation)
- 계산기 검사
- 깊이 우선 탐색 (DFS)

> **프로그램의 함수 호출과 복귀에 따른 실행 순서 관리 과정**
> 1. 함수 호출 발생 시 stack frame에 지역변수, 매개변수, 수행 후 복귀할 주소 등의 정보를 저장해 시스템 스택에 삽입
> 2. 함수 실행이 끝나면 시스템 스택의 top에 있는 stack frame 원소를 pop, frame에 저장된 복귀 주소를 확인하고 복귀
> 3. 함수 호출 - 복귀에 따라 해당 과정을 반복, 전체 프로그램 수행 종료 시 시스템 스택은 공백 스택이 됨
&rarr; 함수 호출은 가장 마지막에 호출된 함수가 가장 먼저 실행 완료하고 복귀하는 후입선출 구조이므로 스택을 이용해 관리 !

--- 

