# Memory Management (메모리 관리 전략)
![memory_management](/contents/Operating_System/img/memory_management.png)

## 메모리 관리 배경 및 이유
- 각 프로세스는 독립된 메모리 공간을 가짐 &rarr; 운영체제 또는 다른 프로세스 메모리 공간에 접근할 수 없음
- **오직 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역 접근에 제약을 받지 않음**

⇒ OS만이 메모리를 접근할 수 있으므로 적절한 관리가 필요함

> **메모리 관리 방식**
- **가상 메모리를 이용한 Swapping**
- **메모리 압축**
- **페이징 & 세그멘테이션**
- **고정 길이 할당 / 가변 길이 할당**

> **메모리 관리를 해야하는 이유**
1. **프로세스 간의 메모리 충돌 방지**
2. **효율적인 자원 활용**
3. **메모리 보호**
4. **프로세스 간의 메모리 공유**
5. **가상 메모리 관리**

---
## 논리 메모리와 물리 메모리
- CPU가 프로세스를 처리할 때, 프로세스가 보는 메모리 영역 : **논리 메모리 영역 OR 가상 메모리 영역**
- **물리 메모리 영역** : 실제 사용되는 메모리 영역 (RAM)
- **논리 주소 OR 가상 주소** : CPU가 프로세스를 실행해 보는 주소 값
- **물리 주소** : 실제 메모리에서 사용되는 주소

![memory_address](/contents/Operating_System/img/memory_address.png)

&rarr; CPU가 프로세스 실행 시 사용하는 주소 값과 실제 주소값이 다르므로, 하드웨어 장치인 **메모리 관리 장치가 논리 주소를 물리 주소로 변환**해야 함

- 메모리 관리 장치(MMU)는 CPU에 위치하고, CPU에서 메모리 접근 전에 메모리 관리 장치를 거쳐 논리 주소를 통해 물리 주소를 얻음
- 메모리 관리 장치를 사용해 메모리 영역에 대한 접근을 제한해 메모리 보호

---
## Fragmentation
: 메모리 공간이 충분함에도 불구하고 프로세스가 메모리에 적재되지 못해 메모리가 낭비되는 현상

![fragmentation](/contents/Operating_System/img/fragmentation.png)

- **내부 단편화** : 할당 받은 영역 중 사용하지 않은 공간으로 인해 공간이 낭비되는 것
- **외부 단편화** : 메모리의 여유 공간이 분산되어 있어(Scattered Holes) 실제로 사용할 수 없는 경우
    - ***동적 메모리 할당 해제를 자주하는 경우 발생함***
    - 외부 단편화 해결 방법 : ***메모리 압축 사용 !***
        - **메모리 압축** : 프로세스가 사용 중인 메모리 공간을 재배치해 흩어진 빈 메모리 공간을 하나로 합침

          ![memory_compression](/contents/Operating_System/img/memory_compression.png)

          &rarr; 8MB, 2MB, 4MB의 빈 메모리 공간이 존재하지만, 프로세스 7의 크기는 10MB이므로 빈 메모리 공간에 할당할 수 없는 외부 단편화 문제가 발생함

          &rarr; 메모리 단축으로 8MB, 2MB의 흩어진 빈 메모리 공간을 재배치해 10MB로 만들고 프로세스 7에게 할당

---
## OS에서 각 프로세스에 메모리를 할당하는 방법

### 연속 메모리 할당
: 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법

⇒ 메모리 할당 = 프로세스가 실행될 수 있도록 필요한 메모리 공간을 확보하고 사용할 수 있게 해주는 것

- **고정 분할 방식** : 메모리를 고정된 크기 블록(Partition)으로 분할 &rarr; 각 영역에 프로세스 할당
    - 단점 : 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한됨 / 단편화 문제 발생 가능
  
    ![continuous_memory_allocation](/contents/Operating_System/img/continuous_memory_allocation.png)
    
    - **외부 단편화** : (b)에서 8MB + 2MB 메모리 공간을 합치면 프로세스 7에 공간 할당이 가능하지만 **고정 분할 방식**이므로 할당 불가한 경우
    - **내부 단편화** : 프로세스 3, 프로세스 4와 같이 분할된 크기보다 작은 프로세스가 할당되는 경우
  
- **가변 분할 방식** : 할당할 프로세스의 크기에 따라 메모리 공간 분할
    - 최초 적합 : 가용 메모리 공간에서 **프로세스 크기만큼** 비어있는 메모리 공간을 찾아 차례대로 프로세스 로드

      ![first_fit](/contents/Operating_System/img/first_fit.png)

      <details>
      <summary>최초 적합 방식</summary>
      
      1. 20MB 프로세스 1은 56MB 메모리 공간에 할당
      2. 18MB 프로세스 2은 36MB 메모리 공간에 할당
      3. 12MB 프로세스 3은 18MB 메모리 공간에 할당
      4. 메모리 영역에서 프로세스 2가 할당 해제됨
      5. 프로세스 4를 할당하기 위해 빈 메모리 공간을 찾고, 가장 먼저 18MB 메모리 공간이 탐색되고, 프로세스 4를 할당

      &rarr; 5번 과정에서 6MB에 프로세스 4를 로드하는 것이 아닌, 18MB 메모리 공간에 프로세스를 로드함
      
      </details>

    - 최적 적합 : 할당하려는 프로세스 크기 이상이 가용 메모리 공간 중 **가장 작은 공간**에 프로세스를 할당하는 방식
 
      ![optimal_fit](/contents/Operating_System/img/optimal_fit.png)

      &rarr; 4번 과정에서 프로세스 4가 할당될 수 있는 빈 메모리 공간은 18MB, 6MB가 존재함

      &rarr; 최초 적합과는 다르게 최적 적합에서는 프로세스 4의 크기와 동일한 6MB 크기의 빈 메모리 공간에 할당
    
    - 최악 적합 : 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중 **가장 큰 공간**에 프로세스를 할당하는 방식

      ![worst_fit](/contents/Operating_System/img/worst_fit.png)

      &rarr; 5번 과정에서 6MB의 프로세스 4를 18MB와 6MB의 빈 메모리 공간에서 가장 큰 18MB의 메모리 공간에 프로세스 4 할당
  
 
### 비연속 메모리 할당
: 프로세스 메모리 영역을 나눠서 메모리 공간에 저장하는 방법

- **페이징** : 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지와 프레임으로 나누는 기법
    - 장점 : 페이지를 물리 메모리에 연속으로 할당할 필요 X &rarr; 외부 단편화 문제 해결
    - 단점
        - 프로세스 크기가 페이지 수로 나누어 떨어지지 않을 경우, 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제 발생 가능
        - 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요함
- **세그멘테이션** : 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당하는 기법
    - 장점 : 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉬움
    - 단점
        -  세그먼트 크기가 균등하지 않아 프로세스 할당 / 해제를 반복하는 과정에서 외부 단편화 문제 발생 가능
        -  메모리에 로드된 스택 세그먼트 영역에서 오버플로 발생 시 다른 프로세스와 메모리 영역이 겹칠 수 있음

        &rarr; 해당 세그먼트 중 하나를 디스크로 스왑 아웃 해야 함
