# Virtual Memory (가상 메모리)
: **컴퓨터의 메모리(RAM)를 보조 저장장치(하드디스크 등)의 일부를 활용해 확장하는 기술**
- 메모리가 실제 메모리보다 많아 보이게 만듦
- ***필요한 부분만 메모리에 올려서 실제 메모리에 올라가는 프로세스 크기를 최소화 시킴 !***

  &rarr; 프로세스 실행 시 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행 가능하다는 점에 착안해 고안됨

- 프로그램 실행 중 RAM 부족으로 문제 발생 가능

&rarr; 가상 메모리를 사용하면 디스크를 RAM의 보조 기억장치처럼 사용해 물리적 메모리보다 더 많은 양의 가상 메모리 사용 가능

⇒ ***이를 위해 OS는 가상 메모리와 물리 메모리 사이의 Mapping을 관리해, 데이터나 명령어를 필요로 할 때마다 보조 저장 장치에서 가져와 RAM에 올리고 사용함***

![mmu](/contents/Operating_System/img/mmu.png)
- **MMU (Memory Management Unit)** : 가상 메모리를 관리하는 특수 메모리 관리 하드웨어
    - 가상 주소를 물리주소로 변환하고, 메모리를 보호하는 기능 수행
 
---
# Swapping
: **주기억장치에 적재한 프로세스를 보조기억장치에 잠시 빼놨다가 필요할 때 다시 꺼내 사용하는 메모리 교체 기법**
- 프로세스 단위로 스와핑을 하는 것은 비효율적이므로 현재는 사용하지 않음
- ***가상 메모리를 관리하는 과정에서는 프로세스 단위가 아닌 페이징 단위로 스와핑을 실행함***

![swapping](/contents/Operating_System/img/swapping.png)

- **보조기억장치** (Secondary storage, Backing storage) : 프로세스를 잠시 빼놓는 공간
- **Swap-out** : 프로세스를 빼놓는 작업
- **Swap-in** : 프로세스를 다시 메모리로 복귀시키는 작업
- 어떤 페이지를 선택해서 우선적으로 swap-out 해야할까? &rarr; **페이지 교체 알고리즘** 사용

#### 발생하는 경우
1. 메모리에 현재 실행 중인 프로세스들을 모두 담지 못할 때
2. CPU를 점유하고 있지만 입출려 등의 작업으로 인해 대기해야 할 때

### Swapping VS Virtual Memory
- Swapping : **프로세스 단위로 swap in, swap out**
- Virtual Memory : **프로세스 일부(페이지 단위)를 swap in, swap out**

---
# Paging
: 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지와 프레임으로 나누는 기법
- **물리 메모리는 Frame**이라는 고정된 크기로 분리되어 있고, **논리 메모리(프로세스가 점유하는)는 Page**라는 고정된 크기의 블록으로 분리
- 장점 : 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 배치됨으로 외부 단편화를 해결할 수 있음
- 단점 : 여유 공간이 남게 되는 내부 단편화 문제가 발생함 / 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요함

![paging](/contents/Operating_System/img/paging.png)
- 페이지 크기 = 프레임 크기
- 페이지와 프레임에 각각 번호를 할당(고유한 페이지 번호를 가짐) &rarr; **페이지 테이블을 사용해 mapping**
- 페이지 테이블 : 프로세스의 페이지 정보 & 페이지에 매핑하는 프레임 정보 저장 / 페이지 테이블은 각 프로세스의 PCB에 저장됨
- ***Virtual Memory를 구현하는 기술 중 하나 !***

## 페이징 기법
1. 계층적 페이징 = 멀티 레벨 페이징
    - 페이지 테이블을 다시 페이지로 나누고, 페이지 테이블 자체를 페이징하는 방식
2. 해시 페이지 테이블
    - 해시 테이블의 각 항목에 저장된 연결 리스트 페이지 번호를 해싱한 뒤 첫번째 요소와 가상 페이지 번호를 비교하는 방식
3. 역 페이지 테이블
    - 프레임을 이용해 페이지를 찾는 방식 / 페이지로 찾는 기존 방식과 반대

## 프로세스 간의 페이지 공유
- 가상 메모리는 `시스템 라이브러리`가 여러 프로세스들 사이에 공유되도록 함
- 각 프로세스는 `공유 라이브러리`를 자신의 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가 있는 `물리 메모리 페이지`들은 모든 프로세스에 공유됨
- 가상메모리는 프로세스들이 메모리를 공유하도록 하고, 프로세스들은 공유메모리로 통신 가능 : 각 프로세스는 각자 자신의 주소 공간처럼 인식하지만 실제 물리 메모리는 공유되고 있음
- 가상 메모리는 **fork()**를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 함

## Demand Paging
: 프로그램 실행 시작 시 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, **초기에 필요한 것들만 적재**하는 전략
- 가상 메모리 시스템에서 많이 사용됨 &rarr; 가상 메모리는 대게 페이지로 관리됨
- 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재됨 : **한번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않음**
- 프로세스 내 개별 페이지들은 `페이저`에 의해 관리됨 &rarr; **필요한 페이지들만 메모리에 읽어, 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄임**

## 페이지 교체
- 프로그램 실행 시 모든 항목이 물리 메모리에 올라오지 않기 때문에 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 `page fault(페이지 부재)`가 발생하게 되면 원하는 페이지를 보조저장장치에서 가져옴
- 하지만 만약 **물리 메모리가 모두 사용중인 상황**이면, 페이지 교체가 이루어져야 함 (운영체제가 프로세스를 강제 종료하는 방법도 있음)

### 기본적인 방법
- 물리 메모리가 모두 사용중인 상황에서의 메모리 교체
1. 디스크에서 필요한 페이지 위치를 찾음
2. 빈 페이지 프레임을 찾음
    - `페이지 교체 알고리즘`을 통해 희생될 페이지를 고름
    - 희생될 페이지를 디스크에 기록하고, 관련 테이블 수정
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정함
4. 사용자 프로세스 재시작

### 페이지 교체 알고리즘
1. **FIFO (First In First Out)** : 먼저 물리메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나감 (메모리에 로드된 시간 기준)

![fifo](/contents/Operating_System/img/fifo.png)

- 장점 : 이해가 쉬움 / 프로그램 하기 쉬움
- 단점
    - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있음 (초기 변수 등)
    - 처음부터 활발히 사용되는 페이지를 교체해서 페이지 내 부재율을 높이는 부작용을 초래할 수 있음
    - Belady의 모순 : 페이지를 저장할 수 있는 프레임 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순 존재

2. **OPT( (Optimal) 최적 페이지 교체** : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체

![opt](/contents/Operating_System/img/opt.png)

- 장점 : 알고리즘 중 가장 낮은 페이지 부재율을 보장함
- 단점 : 구현 어려움 &rarr; 모든 프로세스의 메모리 참조 계획을 미리 파악하기 어려우므로

3. **LRU (Least Recently Used)** : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체

![lru](/contents/Operating_System/img/lru.png)
- 최적 알고리즘과 비슷한 효과로 많은 운영체제가 선택하는 성능 좋은 알고리즘임

4. **LFU (Least Frequently Used)** : 참조 횟수가 가장 적은 페이지를 교체

![lfu](/contents/Operating_System/img/lfu.png)
- 활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정에서 착안
- 최적 페이지 교체를 제대로 근사하지 못해 잘 쓰이지 않음
- 어떤 프로세스가 특정 페이지를 집중적으로 사용하다 다른 기능을 사용하게 되면, 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있음

5. **MFU (Most Frequently Used)** : 참조 횟수가 가장 적은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에서 착안
- 최적 페이지 교체를 제대로 근사하지 못해 쓰이지 않음
- Belady's anomaly 현상이 일어날 수 있음

---
# Segmentation
: 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당하는 기법
- 세그먼트 번호 + offset으로 주소 표현 (물리적 메모리에도 동일하게 적용되어 매핑)
- 장점 : 프로세스 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉬움
- 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재 및 제거되는 일이 반복되면 자유 공간들이 무수한 조각으로 나누어져 못쓰게 되는 외부 단편화 문제 발생 가능
+) 세그먼트 기반 메모리 할당 시 스택 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있어, 이를 해결하기 위해 일부 프로세스를 swap out할 수 있음

![segmentation](/contents/Operating_System/img/segmentation.png)

- **세그멘테이션 테이블을 사용해 세그먼트의 논리주소를 물리 주소로 mapping**
- segment table은 세그먼트 번호를 인덱스로 사용하며, 세그먼트별 시작 주소인 base와 길이인 limit을 저장함

# Segment-Page
: **Segmentation 당 페이지 테이블을 유지하면서 논리 주소를 segment 번호 + page 번호 조합으로 변환해 물리 주소를 얻는 방식**
- 세그먼트 & 페이징 방식의 장점을 결합하여 세그먼트에서 발생하는 외부 단편화, 페이징에서 발생하는 내부 단편화를 모두 해결 가능
- 가상 메모리 구현 기법 중 하나
- 매핑 테이블을 2번 거쳐야하므로 매핑 속도가 상대적으로 느릴 수 있지만, 가상 메모리 개념을 도입해 물리 메모리가 부족한 경우에도 프로세스 실행 가능
- **대부분 최신 운영 체제에서 해당 방식을 사용**하고 있음 (매핑 테이블의 크기가 커지는 경우 세그먼트와 페이지 크기를 조정해 문제 해결 가능)