# Dead Lock
- 프로세스들이 서로 가진 자원을 기다리며 block되어 더 이상 진행이 될 수 없는 상태

⇒ **둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 무한히 기다리는 상황**

---
## 프로세스 자원 사용 절차
- **Request** : 자원 요청, 만약 다른 프로세스가 자원을 사용하고 있어 받을 수 없으면 대기
- **Allocate** : 자원을 받음
- **Use** : 프로세스가 받은 자원을 사용
- **Release** : 프로세스가 자원을 놓아줌

&rarr; ***Dead Lock은 모든 프로세스가 Request 상태가 되어있는 상황***

---
## Dead Lock Characterization (발생 조건) / Prevention (예방)
1. ### Mutual Exclusion (상호 배제)
    - **한번에 프로세스 하나만 해당 자원 사용**
    - 예방 ) 공유자원이 존재하면 해당 조건을 반드시 만족해야 함, 공유 자원이 없다면 한번에 여러 프로세스가 공유 자원을 사용할 수 없게 만듦
2. ### Hold and Wait (점유 대기)
    - **자원을 최소 하나 보유하고 있고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함**
    - 예방 ) 프로세스가 자원 요청 시 다른 어떤 자원도 못 가지게 함
        - 프로세스 시작 시 모든 필요한 자원을 할당받게 하거나, 자원이 필요한 경우 보유한 자원을 모두 반납하고 다시 요청
3. ### No Preemption (비선점)
    - **이미 할당된 자원을 빼앗을 수 없음**
    - 예방 ) 프로세스가 특정 자원을 기다려야 하는 경우 보유하고 있던 자원이 선점됨, 모든 필요 자원을 얻을 수 있을 때 해당 프로세스는 다시 시작
4. ### Circular wair (순환 대기)
    - **자원을 대기하는 프로세스들은 순환 형태 (사이클)로 자원을 대기**
    - 예방 ) 자원 타입에 따라 프로세스마다 할당 순서를 정해 정해진 순서대로만 자원 할당

&rarr; Resource-Allocation Graph에 **Cycle**이 있다면 deadlock이 발생할 가능성이 있음

&rarr; Dead Lock 해결 방법으로는 위의 4가지 조건을 제거하는 방법이 있으나, 자원 사용 효율성이 떨어지며 비용이 많이 듦

---
## Dead Lock Avoidance (회피)
- dead lock 예방은 시스템 처리량이나 효율성을 떨어트릴 수 있음
- 반면 dead lock 회피는 발생 가능성이 있는 경우에는 아예 자원을 할당하지 않는 방식으로, 프로세스들이 필요로 하는 자원별 최대 사용량을 미리 선언

- **Safe State** : 시스템의 프로세스들이 요청하는 모든 자원을 데드락을 발생시키지 않으면서 모두에게 할당 가능하다면 안정 상태에 있다고 함
- **Safe Sequence** : 특정 순서로 프로세스들에게 자원 할당, 실행 및 종료 등의 작업 시 데드락이 발생하지 않는 순서를 찾을 수 있따면 안전 순서라 부름

&rarr; 시스템이 safe state에 있으면 dead lock이 발생하지 않음

⇒ ***Dead lock avoidance는 시스템이 Unsafe State에 들어가지 않는 것을 보장함***

### 회피 알고리즘 1. 은행원 알고리즘
- **'최소한 고객 한 명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다'** 개념에서 시작
- 교착 상태에 빠질 가능성이 있는지 판단하기 위해 **안전 상태 & 불안전 상태**로 나누고, 안전 상태를 유지할 수 있는 요구만 수락하며 불안전 상태를 초래할 사용자 요구는 계속 거절하는 방식

- 수행을 위한 3가지 요소
    - **Max** : 각 프로세스가 자원을 최대로 얼마까지 요청 가능한지
    - **Allocated** : 각 프로세스가 현재 보유하고 있는 자원이 얼마인지
    - **Available** : 시스템이 자원을 얼마나 보유하고 있는지

![deadlock_avoidance1](/contents/Operating_System/img/deadlock_avoidance1.png)

- 시스템은 12개의 자원을 가지며, 프로세스는 P1, P2, P3가 존재
- P1은 10개, P2는 4개, P3는 9개의 자원이 각각 필요
- 0 시각에 P1이 5개, P2가 2개, P3가 2개의 자원을 가져가고 시스템에 3개의 자원이 남는다 가정 (0 시각에 시스템은 안전 상태)
- 1 시각에 Case1과 같이 P2에 2개의 자원을 할당하고 P2 작업이 끝난 후 4개의 자원을 돌려받아 P1이나 P3의 작업을 완료할 수 있는 안전 순서 열이 존재함 (P2 &rarr; P1 &rarr; P3 or P2 &rarr; P3 &rarr; P1)
- 하지만 시스템은 안전 상태에서 불안전 상태로 변할 수 있음
- 예 ) 안전상태였던 0 시각에서 시간이 흘러 1 시각에 Case2의 상황이 발생하는 경우
    - P3가 자원을 하나 더 요청해 자원을 할당하면 시스템이 가지고 있는 자원은 2가 됨 (안전 순서 열 존재 X)
    - P1을 완료하려면 5개의 자원이 더 필요하며, P2는 2개의 자원이 더 필요해 현재 자원을 다 빌려주더라도 돌아오는 자원은 4개뿐이라 P1, P3 모두 해결 불가능 (1 시각은 불안전 상태)
- 운영체제가 1 시각에 P3가 자원 요청 시, 빌려줘야 할까?
    - 교착 상태에 빠질 가능성이 있으면 빌려주지 않고 P2를 먼저 끝내는 안전 순서열을 지키면 교착 상태에 빠지지 않고 해결 가능


- 은행원 알고리즘의 단점
    - 할당할 수 있는 자원 및 사용자 수가 일정해야 함
    - 항상 불안전 상태를 방지해야하므로 자원 이용도가 낮음 / 프로세스들은 유한한 시간안에 자원 반납
    - 최대 자원 요구량(MAX)을 미리 알아야 함

&rarr; 결국 은행원 알고리즘은 구현이 복잡하며, 프로세스 최대 자원 요구량을 미리 알아야 한다는 점에서 실질적 사용은 어려움


### 회피 알고리즘 2. 자원 할당 그래프 알고리즘
- 각 자원 유형의 단위 자원이 하나 밖에 없는 경우에 사용, 자원할당 그래프를 통해 교착 상태를 탐지하고 회피함

![deadlock_avoidance2](/contents/Operating_System/img/deadlock_avoidance2.png)
- 그래프에 사이클이 존재하는지 확인
- 사이클이 존재할 경우, 자원 유형에 몇 개의 사례가 있는지 확인
- 하나의 사례만 있으면 교착 상태, 여러 사례가 있으면 교착 상태 가능성이 있다고 판별

- 구현
    - 프로세스가 자원 요청
    - 요청 간선 추가
    - 요청 간선을 할당 간선으로 변환
    - 교착 상태 예측 후 불안전 상태일 경우 대기, 안전 상태일 경우 요청 승인

- 단점
    - 자원 요청 시, 탐지 알고리즘을 실행하므로 오버헤드가 발생해 성능에 영향을 끼칠 수 있음 

![deadlock_avoidance2_exception](/contents/Operating_System/img/deadlock_avoidance2_exception.png)
- 사이클이 있지만 교착 상태가 아닌 예시
    - 프로세스 P1이 작업을 완료하고 R3의 자원을 반환하면 P3는 P1이 반환한 자원을 할당 받으면 됨

----
## Dead Lock 해결 방법
1. 예방 : 교착 상태의 4가지 조건 부정
2. 회피
    - 은행원 알고리즘
    - 자원 할당 그래프 알고리즘
3. 탐지 : 회복을 위해 우선 탐지해야함
    - 대기 그래프 : 각 자원 유형의 단위자원이 하나일 경우 사용
        - 자원 할당 그래프에서 자원 노드를 제거하고 프로세스 간의 간선으로 나타낸 그래프
    - Shoshanni & Coffman 알고리즘 : 각 자원 유형의 단위자원이 여러개일 경우 사용
        - 은행원 알고리즘에서 사용하는 자료구조인 Available, Allocation, Request 사용
4. 회복 : 교착 상태 발생 후 교착 상태를 일으킨 프로세스를 탐지해 종료하거나 할당된 자원을 해제해 회복함
    - 프로세스 종료법 : 교착 상태의 프로세스를 종료해 자원 회수
        - 전체 종료 : 교착 상태의 프로세스를 모두 중지
        - 부분 종료 : 교착 상태가 제거될 때까지 하나씩 프로세스 중지
    - 자원 선점법 : 교착 상태 사이클이 없어질 때까지 자원을 빼앗아 다른 프로세스에게 제공

## Deadlock Ignorance (데드락 무시)
- **Deadlock이 일어나지 않는다 생각하고 아무 조치도 취하지 않는 방식**
- 위의 4가지 해결 기법들을 사용할 경우 성능에 큰 영향을 미칠 수 있음 : 해당 조치 자체가 더 큰 오버헤드를 일으킴
- 교착 상태는 자주 발생하지 않으므로 발생 확률이 낮은 경우 조치를 취하지 않고 비정상 작동시 직접 프로세스를 죽임
- Unix, Windows 등 대부분 운영체제가 채택한 방식 ! 

---
## Dead Lock과 Starvation은 같은 개념일까?
- Dead lock & Starvation은 자원 할당을 무한히 대기한다는 점에서 같아보이지만 차이가 존재함
- Dead Lock : 여러 프로세스나 스레드가 절대 발생하지 않는 이벤트나 자원 할당을 위해 무한정 대기
    - 프로세스 상태 중 **Blocked** 상태에서 발생
- Starvation : 프로세스가 CPU 자원의 할당을 무한히 대기 (CPU 스케쥴링과 연관)
    - 프로세스 상태 중 **Ready** 상태에서 발생