**생성 주체에 따라 구분**
- 사용자가 라이브러리를 통해 만들고 관리 = ***사용자 수준 스레드***
- OS의 커널이 만들고 관리 = ***커널 수준 스레드***

---
# Kernel-Level Thread
- 커널 레벨에서 생성되는 스레드 &rarr; 운영체제 시스템 내에서 생성되어 동작하는 스레드, 커널이 직접 관리
- 커널 수준에서는 **프로세스가 주기억 장치에 여러 개 적재되어 CPU 할당을 기다리며 동작함**
- **사용자 수준 스레드와 1대1로 매핑됨**
- 프로세스 내에 스레드 라이브러리가 없어 **커널 스레드를 스케줄 하여 매핑된 사용자 스레드를 동작시킴**
- **커널이 전체 TCB와 PCB 관리**

- **Context Switching이 일어날 때는 CPU가 일을 못함** &rarr; 자주 발생 시 성능에 영향을 줌
- But 커널이 직접 개별적으로 관리하므로 **특정 스레드가 block 되어도 다른 스레드들은 독립적으로 일을 함**

- ***Context Switching***
    - CPU에서 interrupt 발생으로 현재 작업 중이 프로세스가 block되고 다른 프로세스로 변경할 때 CPU 내 재배치 레지스터에 다음 실행할 프로세스 정보들로 교체를 하고 캐시를 비움

> - 장점
>    - 사용자 수준 스레드보다 효율적 &rarr; 멀티프로세서 활용 가능
>        - 사용자 스레드는 cpu가 많아도 커널 모드의 스케줄이 불가능하므로, 각 cpu에 효율적으로 스레드 배당이 불가능
>    - 동작중인 스레드가 System call(커널 호출) 해도 해당 프로세스 내 다른 스레드는 계속 실행 가능
>
> - 단점
>    - context switching이 발생
>        - 프로세서 모드가 사용자 모드 & 커널 모드 사이 전환을 빈번히 하므로 성능이 떨어짐
>    - 스케줄링과 동기화를 위해 system call하는데 오래 걸림

![kernel-level](/contents/Operating_System/img/kernel-level.png)

### 왜 해당 형태가 커널 수준 스레드 모델인가 ?
- 하나의 프로세스는 기본적으로 하나 이상의 스레드를 가지며 **사용자 레벨과 동기화 할 수 있도록 User level쪽에도 스레드가 생성됨**
- 해당 사용자 레벨 스레드는 **프로세스에 대한 사용자의 입/출력을 받도록 하는 커널 통제권 밖의 스레드임**
- **사용자 입출력이 필요한 프로세스는 실제 2개 이상의 스레드를 가짐**
- 결국 ***커널 스레드에 사용자 수준 스레드가 각 하나씩 붙어 처리하는 형태가 커널 수준 스레드 모델임 !***

![kernel-level_thread_model](/contents/Operating_System/img/kernel-level_thread_model.png)

- 최근 운영체제들은 one-to-one model을 사용함

---
# User-Level Thread
- **스레드를 관리하는 라이브러리로 인해 사용자 단에서 생성 및 관리되는 스레드** &rarr; 커널이 따로 관리 X
- **사용자 수준 스레드 N개가 커널 수준 스레드 1개에 매핑됨**
- 프로세스 내에 **스레드 라이브러리가 있어 커널 도움 없이 스레드 스케줄링 가능**
- ***스레드 정보(TCB, Thread Control Block)는 프로세스 내에서 / 프로세스 정보(PCB, Process Control Block)는 커널에서 관리***

> - 장점
>    - 스케줄링과 동기화를 위해 System Call을 하지 않아 오버헤드가 적음 (Context Switching을 프로세스 내부에서 진행)
>    - 커널이 스레드의 존재를 모르므로 유저모드와 커널모드 간의 전환이 없음 &rarr; 프로세스 하나로 봄
> 
> - 단점
>    - 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지함 = **Blocking System Call** (커널이 스레드의 존재를 알지 못하므로)
>    - 스케줄링 우선순위를 지원하지 않으므로 어떤 스레드가 먼저 동작할지 모름 &rarr; 라이브러리를 통해 스케줄링

![user-level](/contents/Operating_System/img/user-level.png)

### 왜 해당 형태가 사용자 수준 스레드 모델인가 ?
- 사용자 수준 스레드는 하나의 커널에 여러 스레드가 붙음 &rarr; 스레드 전용 라이브러리로 사용자 레벨에서 여러 스레드 생성
- 해당 스레드는 **프로세스 내 커널과 관련 없는 기능들만 수행하는 스레드**
- 따라서 사용자 수준 스레드는 **context switching이 일어나지 X** &rarr; 스레드 교체 등으로 인한 오버헤드가 발생하지 않음
- 대신 **interrupt 발생 시 모두 block됨**


### 스레드는 프로세스 단위라면서 어떻게 운영체제 레벨인 커널 밖에서 생성 및 이용 가능한가 ?
- 실제 물리적 커널 밖에 있는게 아님 &rarr; 커널 내부에 존재하지만 **커널 통제권 안에 없을 뿐**
- 커널에는 `커널 모드`와 `사용자 모드`가 존재하며 **사용자 모드에서 동작하는 스레드가 user-level thread임**
- 입출력 인터럽트 발생 시 커널은 **사용자 모드**가 되어서 사용자 수준 스레드의 응답을 기다림
- 사용자 수준 스레드의 응답이 오면 다시 **커널 모드**로 변환되어 커널 스레드가 일처리 진행


### 스레드는 프로세스 내 작업 단위인데, 사용자 수준 스레드는 어떻게 프로세스 없이 스레드만 생성 가능한가 ?
- 사용자 수준 스레드는 생성 시 프로세스 단위로 생성되므로, 프로세스 겸 스레드라 볼 수 있음
- 이러한 특징으로 커널 스레드와 다르게 **멀티 스레드 방식으로 동작이 어려움**