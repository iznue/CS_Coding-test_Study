# System Call

![cpu_mode](/contents/Operating_System/img/cpu_mode.png)

- 운영체제는 시스템을 보호하기 위해 `사용자 모드`, `커널 모드`로 나누어 동작함
- CPU에 있는 Mode bit로 모드를 구분해 0은 커널, 1은 사용자 모드로 나뉘어 구동
    - 사용자 모드 : 하드웨어 및 메모리 영역 접근에 제한이 있음 &rarr; 접근을 위해 system call 사용
    - 커널 모드 : 모든 시스템 메모리, CPU Instruction, H.W에 직접 접근 가능

    &rarr; 커널 모드가 더 높은 권한을 가져 사용자모드에서 유저 애플리케이션의 필요에 따라 커널 모드로 변환해 시스템 영역 접근 가능

⇒ ***System Call = 사용자 모드에서 커널 모드로 전환하기 위해 필요한 인터페이스 = OS가 제공하는 인터페이스***
- OS는 하드웨어를 직접 관리하지만 응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원 사용 가능
- 보통 API (라이브러리 함수)를 통해 사용

---
## System Call을 사용하는 이유 ?
1. **유저 애플리케이션이 운영체제의 치명적인 데이터를 수정 / 삭제하는 권한을 막기 위함**
    - 직접적인 하드웨어 요청 및 기타 시스템 요청은 OS가 제공하는 System call을 통해 호출
2. 유저 레벨 프로그램은 유저레벨 함수들만으로 많은 기능을 구현하기 어려워 **커널의 도움을 받아야 함**
    - 반드시 커널 모드로 전환한 후에야 해당 작업 수행 권한이 생김
 
⇒ 시스템 전체가 망가지는 것을 방지하기 위해 특별히 **커널 모드에서만 실행하도록 권한이 부여됨**

⇒ **만약 유저 모드에서 시스템 콜을 호출한 경우 운영체제에서 불법접근이라 여기고 trap 발생**

---
## System Call 사용

#### 처리 방식
1. 사용자 프로세스가 시스템 콜 호출 (커널 모드 진입)
2. 커널은 내부적으로 시스템 콜 구분을 위해 기능별로 고유번호를 할당하고 그 번호에 해당하는 제어 루틴 정의
3. 커널은 요청받은 시스템 콜에 대응하는 고유번호를 확인하고 번호에 맞는 서비스 루틴 호출
4. 커널은 서비스 루틴 처리, cpu에게 인터럽트를 발생시켜 수행 완료를 알리고 사용자 모드로 전환

- 각 시스템 콜에는 번호가 할당되고, 시스템 콜 인터페이스는 **시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성되는 시스템 콜 테이블을 유지함**

#### 유형
1. **프로세스 제어** &rarr; 프로세스 실행, 생성, 대기 등
    - fork()
    - exec()
    - wait()
    - exit()
    - signal event
    - 메모리 할당 및 해제

2. **파일 조작** &rarr; 파일 열기, 읽기, 쓰기 등
    - open()
    - read()
    - write()
    - close()
    - reposition()
    - get / set file attribute()

3. **장치 관리** &rarr; 디바이스 부착, 분리, 읽기, 쓰기 등
    - ioctl()
    - read()
    - write()

4. **정보 유지** &rarr; 날짜, 시간 설정 등
    - getpid()
    - alarm()
    - sleep()
    - time()
    - date()

5. **통신** &rarr; 통신 연결 생성, 제거, 상태 정보 전달 등
    - pipe()
    - shm_open()
    - mmap()

6. 보호
    - chmod()
    - umask()
    - chown()