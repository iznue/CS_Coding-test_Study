# Shortest Path

---
## Dijkstra
- 가중치가 있는 그래프에서 한 출발 노드로부터 다른 모든 노드까지의 최단 경로를 찾는 알고리즘
- **음의 가중치를 갖는 간선이 없는** 그래프에서만 사용 가능
- **greedy + dynamic programming**을 합쳐서 구현
- 각 정점을 최대 한 번만 방문해 최단 거리를 확정함
- 최단거리가 최소인 정점을 찾는 과정에서 **priorityqueue or heap** 자료구조를 이용하면 개선된 알고리즘 사용 가능

![다익스트라](https://user-images.githubusercontent.com/22045163/106482569-eca38480-64f0-11eb-9c52-28a886a9f947.gif)

#### 기본 구조와 동작
1. 시작 노드를 설정하고 초기 거리를 0으로 설정 (D[S] = 0 / heap에 노드 정보 [S, 0] 처리)
2. 나머지 모든 노드의 거리를 무한대로 설정
3. 우선순위 큐를 이용해 현재 노드의 최단 경로 확정
4. 현재 노드와 인접한 노드들의 거리 업데이트 (D[J] = D[I] + W로 갱신될 경우 힙에 노드 J([J, D[J]) 삽입)
5. 모든 노드의 최단 경로가 확정될 때까지 3, 4번 과정 반복

#### 시간복잡도
- 0(Elog V) (E : 간선의 수, V : 정점의 수)
> **방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택**하는 과정에서 비용 발생
> - 방문했는지 여부에 대한 정보를 저장하는 배열을 노드의 크기(V)만큼 생성하고 접근
> - D 배열을 모두 순회하여 최단 거리가 짧은 노드를 선택

&rarr; 이 과정을 priority queue or heap 자료구조를 이용하면 노드를 선택하는 비용을 0(V)에서 0(log{heap에 저장한 정점의 개수})로 줄일 수 있음

&rarr; 최단거리가 가장 짧은 노드를 선택해야 하므로 **최소 힙**을 사용하며, 힙을 통해 구현된 **priority queue**를 사용해도 됨

#### 구현
[Dijkstra](./code/shortest_path/dijkstra.py)

---
## Bellman-Ford Moore
- 음의 가중치를 갖는 간선이 포함된 그래프에서 최단 경로를 찾는 알고리즘
- 다익스트라와 달리 음의 가중치가 있는 경우에도 결과 도출 가능
- 음수 사이클이 존재하는 경우 정상적인 구혀닝 되지 않으며, 매번 모든 간선들을 확인해야 하므로 다익스트라보다 시간이 느림
- 그래프 G = (V, E)에서 특정 출발 정점(S)에서 다른 모든 정점까지의 최단 경로를 구함

![벨만포드](https://user-images.githubusercontent.com/22045163/106553083-f6160680-655b-11eb-8da9-cda67af0493e.gif)

#### 기본 구조와 동작
1. 모든 노드의 거리를 무한대로 설정, 출발 노드 s 설정
2. 시작 노드의 거리를 0으로 설정
3. 모든 간선을 반복적으로 확인하며, 각 간선의 길이를 통해 최단 경로 갱신 &rarr; 각 노드로 가는 비용을 계산해 최단 거리 배열 d 갱신
4. 3의 과정을 (노드의 개수 -1) = v-1번 반복
5. 음수 사이클을 감지하기 위해 모든 간선을 추가로 한번 더 확인 &rarr; 3의 과정을 한번더 반복했을 때 배열 d가 갱신되면 음의 사이클이 있는 것으로 판단
&rarr; 가중 그래프 (v, e)에서 어떤 정점 a에서 b까지의 최단 거리는 최대 v-1개의 간선을 사용 (= 시작 정점 a를 포함해 최대 v개의 정점을 지남)

#### 시간복잡도
- O(VE) (E : 간선의 수, V : 정점의 수)
&rarr; 최단 거리를 구하기 위해 v-1번 e개의 모든 간선을 확인함
&rarr; 음의 사이클 존재 여부 확인을 위해 한 번 더(v번째) e개의 간선 확인, 따라서 v*e번 연산함

#### 구현
[Belman-Ford](./code/shortest_path/bellman_ford.py)

---
## Floyd-Warshall
- 플로이드-워셜은 모든 정점 쌍 간의 최단 경로를 찾는 알고리즘
- 가중치가 음수인 그래프에서도 동작하지만, 음수 사이클이 없어야 함
- 그래프 G = (V, E)에서 모든 정점 사이의 최단 경로를 구하는 알고리즘
- 어떤 두 정점 사이의 최단 경로는 어떤 경유지(K)를 거치거나, 거치지 않는 경로 중 하나임 &rarr; 즉 정점 a, b 사이의 최단 경로는 a-b 이거나 a-k-b임
- 만약 경유지를 거치면 최단 경로를 이루는 부분 경로 역시 최단 경로임, 즉 a-b의 최단 경로가 a-k-b라면 a-k와 k-b도 각각 최단 경로임

![플로이드워셜](https://user-images.githubusercontent.com/22045163/106489876-95091700-64f8-11eb-91fa-bd903685f284.gif)

#### 기본 구조와 동작
1. 각 정점 쌍 간의 초기 거리 설정
- 각 정점 쌍 (i, j)간의 초기 거리 설정
- 자기 자신에게 가는 거리는 0으로 설정하고, 직접 연결된 간선이 있는 경우 그 간선의 가중치로 설정.
- 연결이 없는 경우 무한대 (INF)로 설정
2. 모든 정점을 중간 정점으로 사용해, 정점 i에서 j로 가는 최단 경로를 갱신
- 모든 정점을 중간 정점으로 사용해, 정점 i에서 j로 가는 최단 경로를 갱신
- (k는 중간 정점, i는 출발 정점, j는 도착 정점) ```dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])```
3. 최종 결과로 모든 정점 쌍 간의 최단 거리를 얻음
&rarr; 동적계획법으로 접근함

#### 시간복잡도
- 0(V<sup>3</sup>)
- 모든 가능한 경유지에 대해 모든 정점 &rarr; 모든 정점으로 가는 최단 거리를 확인하므로 연산 횟수는 V<sup>3</sup>임

#### 사용 예시
- 네트워크의 모든 노드 간 최단 경로 계산
- 그래프 분석

#### 구현 
[Floyd-Warshall](./code/shortest_path/floyd_warshall.py)
