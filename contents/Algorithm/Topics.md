# Algorithm
- 알고리즘은 완전탐색(모든 경우의 수를 탐색)에서 시쟉됨 &rarr; 모든 경우의 수를 고려하지만 최대 시간 복잡도를 가짐
- 순차적(concatenation)구조 : 코드가 위 아래 순차적으로 실행되는 구조
- 선택적(selection)구조 : 조건에 따른 결과에 따라 프로그램 실행 흐름을 변경하는 구조
- 성능평가 Case
     - 최선의 경우 (best case) : 최적의 입력 상태에서 작업을 완료하는데 가장 연산 횟수가 적은 경우
     - 최악의 경우 (worst case) : 최악의 입려 상태에서 작업을 완료하는데 가장 연산 횟수가 많은 경우
    
    &rarr; 알고리즘 분석 시 **최악의 경우 & 시간 복잡도**로 성능을 파악함

- **좋은 코드 구성을 위해 고려할 점**
  1. 문제를 파악하고 구체적 계획 및 알고리즘 생각
  2. 공간복잡도와 시간복잡도를 계산해 제약 조건 내에 수행될 수 있는 알고리즘인지 판단

---
## 시간복잡도 / 공간복잡도
- **알고리즘의 성능 및 효율성을 나타내는 척도** &rarr; 보통 수행 시간과 메모리 사용량을 기준으로 함
- 각 알고리즘이 주어진 특정 크기 입력(n)을 기준으로 수행시간(연산) or 사용 공간이 얼마나 되는지 객관적으로 비교하는 기준
- 점금 표기법 : O(빅오), Ω(오메가), Θ(세타)...

### 시간복잡도 (Time Complexity)
- 특정 크기 입력(n)을 기준으로 할 때 필요한 연산 횟수
- 알고리즘을 구성하는 명령어들이 몇번이나 실행되는지 센 결과에 각 명령어의 실행시간을 곱한 합계
- why 실행 시간이 아닌 연산횟수로 계산?
     &rarr; 모든 OS, IDE, platform에서 동일한 결과가 나오지 x, 실행 시간 측정을 위한 다른 방법이 필요함

### 공간복잡도 (Space Complexity)
- 프로그램 실행과 완료에 얼마나 많은 공간(**메모리**)가 필요한지
- 알고리즘 실행을 위한 공간
  1. 고정 공간 : 코드가 저장되는 공간, 알고리즘 실행을 위해 시스템이 필요로 하는 공간 (알고리즘과 무관)
  2. **가변 공간** : 변수 저장, recursion stack 등 (알고리즘과 밀접)
 
[complexity_detail](./Complexity.md)

---
## 완전탐색 (Brute-Force)

### DFS (Depth First Search, 깊이 우선 탐색)
- 그래프에서 깊은 부분을 우선적으로 탐색
- stack, 재귀함수를 이용해 구현
- 유의할 점 : stack overflow
- 활용 예 : 백트래킹, 단절선/단절점 찾기, 위상정렬, 사이클 찾기 등

> #### 구현 방법
> 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
> 2. 스택 최상단 노드에 방문하지 않은 인접 노드가 있으면 해당 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄
> 3. 2번 과정을 더 수행할 수 없을 때까지 반복

## BFS (Breadth First Search, 너비 우선 탐색)
- 그래프에서 가까운 노드부터 탐색
- queue를 이용해 구현
- 유의할 점 : 메모리 초과 (방문체크 반드시 하기)
- 활용 예 : 최단경로 찾기, 위상정렬 등

> #### 구현 방법
> 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
> 2. 큐에서 노드를 꺼내 해당 노드의 인접 노등 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
> 3. 2번 과정을 더 수행할 수 없을 때까지 반복

--- 
## 순열 / 조합 / 부분집합

### 순열 
- **n개의 원소에서 순서를 생각하며 r개의 원소를 선택하는 방법**
- 뽑은 원소의 구성이 같아도 순서가 다르게 뽑혔으면 다른 경우의 수가 됨
- 'nPr = n * (n-1) * (n-2) * ... * (n-r+1)' / 'nPn = n!' &rarr; 10!이상의 계산은 위험함
- **재귀함수, 비트마스크, next permutation**으로 구현

### 조합
- n개의 원소에서 r개의 원소를 선택하지만 **원소를 뽑는 순서는 고려하지 않음**
- 뽑는 순서는 고려하지 않으므로 해당 원소를 뽑는지만 생각하면 됨
- 무조건 r개를 뽑아야 함
- 'nCr = n! / (n-r)!r!'
- **재귀함수, next pemutation**으로 구현

### 부분집합 (Power set)
- 집합의 원소 일부로 이루어진 집합으로, 자기 자신 & 공집합도 부분집합에 해당
- 각각의 원소를 선택하는 경우, 선택하지 않는 경우 두 경우로 나뉘며 전체 Big-O는 0(2<sup>n</sup>)이 됨
- **재귀함수, 바이너리 카운팅**으로 구현

---
