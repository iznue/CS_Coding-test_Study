# Algorithm
- 알고리즘은 완전탐색(모든 경우의 수를 탐색)에서 시쟉됨 &rarr; 모든 경우의 수를 고려하지만 최대 시간 복잡도를 가짐
- 순차적(concatenation)구조 : 코드가 위 아래 순차적으로 실행되는 구조
- 선택적(selection)구조 : 조건에 따른 결과에 따라 프로그램 실행 흐름을 변경하는 구조
- 성능평가 Case
     - 최선의 경우 (best case) : 최적의 입력 상태에서 작업을 완료하는데 가장 연산 횟수가 적은 경우
     - 최악의 경우 (worst case) : 최악의 입려 상태에서 작업을 완료하는데 가장 연산 횟수가 많은 경우
    
    &rarr; 알고리즘 분석 시 **최악의 경우 & 시간 복잡도**로 성능을 파악함

- **좋은 코드 구성을 위해 고려할 점**
  1. 문제를 파악하고 구체적 계획 및 알고리즘 생각
  2. 공간복잡도와 시간복잡도를 계산해 제약 조건 내에 수행될 수 있는 알고리즘인지 판단

---
## 시간복잡도 / 공간복잡도
- **알고리즘의 성능 및 효율성을 나타내는 척도** &rarr; 보통 수행 시간과 메모리 사용량을 기준으로 함
- 각 알고리즘이 주어진 특정 크기 입력(n)을 기준으로 수행시간(연산) or 사용 공간이 얼마나 되는지 객관적으로 비교하는 기준
- 점금 표기법 : O(빅오), Ω(오메가), Θ(세타)...

### 시간복잡도 (Time Complexity)
- 특정 크기 입력(n)을 기준으로 할 때 필요한 연산 횟수
- 알고리즘을 구성하는 명령어들이 몇번이나 실행되는지 센 결과에 각 명령어의 실행시간을 곱한 합계
- why 실행 시간이 아닌 연산횟수로 계산?
     &rarr; 모든 OS, IDE, platform에서 동일한 결과가 나오지 x, 실행 시간 측정을 위한 다른 방법이 필요함

### 공간복잡도 (Space Complexity)
- 프로그램 실행과 완료에 얼마나 많은 공간(**메모리**)가 필요한지
- 알고리즘 실행을 위한 공간
  1. 고정 공간 : 코드가 저장되는 공간, 알고리즘 실행을 위해 시스템이 필요로 하는 공간 (알고리즘과 무관)
  2. **가변 공간** : 변수 저장, recursion stack 등 (알고리즘과 밀접)
 
[complexity_detail](./Complexity.md)

---
## 완전탐색 (Brute-Force)

### DFS (Depth First Search, 깊이 우선 탐색)
- 그래프에서 깊은 부분을 우선적으로 탐색
- stack, 재귀함수를 이용해 구현
- 유의할 점 : stack overflow
- 활용 예 : 백트래킹, 단절선/단절점 찾기, 위상정렬, 사이클 찾기 등

> #### 구현 방법
> 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
> 2. 스택 최상단 노드에 방문하지 않은 인접 노드가 있으면 해당 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄
> 3. 2번 과정을 더 수행할 수 없을 때까지 반복

## BFS (Breadth First Search, 너비 우선 탐색)
- 그래프에서 가까운 노드부터 탐색
- queue를 이용해 구현
- 유의할 점 : 메모리 초과 (방문체크 반드시 하기)
- 활용 예 : 최단경로 찾기, 위상정렬 등

> #### 구현 방법
> 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
> 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
> 3. 2번 과정을 더 수행할 수 없을 때까지 반복

--- 
## 순열 / 조합 / 부분집합

### 순열 
- **n개의 원소에서 순서를 생각하며 r개의 원소를 선택하는 방법**
- 뽑은 원소의 구성이 같아도 순서가 다르게 뽑혔으면 다른 경우의 수가 됨
- 'nPr = n * (n-1) * (n-2) * ... * (n-r+1)' / 'nPn = n!' &rarr; 10!이상의 계산은 위험함
- **재귀함수, 비트마스크, next permutation**으로 구현

### 조합
- n개의 원소에서 r개의 원소를 선택하지만 **원소를 뽑는 순서는 고려하지 않음**
- 뽑는 순서는 고려하지 않으므로 해당 원소를 뽑는지만 생각하면 됨
- 무조건 r개를 뽑아야 함
- 'nCr = n! / (n-r)!r!'
- **재귀함수, next permutation**으로 구현

### 부분집합 (Power set)
- 집합의 원소 일부로 이루어진 집합으로, 자기 자신 & 공집합도 부분집합에 해당
- 각각의 원소를 선택하는 경우, 선택하지 않는 경우 두 경우로 나뉘며 전체 Big-O는 0(2<sup>n</sup>)이 됨
- **재귀함수, 바이너리 카운팅**으로 구현

---
## 백트래킹 (Backtracking)
- **DFS 방식을 기반**으로, **불필요한 경우를 배제하며 원하는 해답에 도달할때까지 탐색**하는 전략
     - DFS 문제에서 모든 노드를 탐색할 필요가 없을 경우 적용
- **스택**을 이용해 퇴각하며 다음 탐색을 진행함

> #### 알고리즘
> - 유망하다(promising) : 어떤 노드 방문 시 그 노드를 포함한 경로가 해답이 될 수 있음
> - 가지치기(pruning) : 유망하지 않은 노드가 포함된 경로는 더 이상 고려하지 않음
> 1. 상태 공간 트리의 DFS를 시행
> 2. 각 노드가 유망한지 검사
> 3. 만약 해당 노드가 유망하지 않으면, 그 노드의 부모로 되돌아가 다음 자식 노드로 검색 진행
&rarr; 대표적으로 **N-Queen 문제**가 백트래킹의 예시임

---
## 정렬 알고리즘 (Sorting)

### 선택 정렬 (Selection sort)
- 현재 위치에 들어갈 값을 찾아 정렬하는 배열
- 최소 선택정렬 : 오름차순 / 최대 선택정렬 : 내림차순
- 정렬되지 않은 배열에서 가장 작은 숫자를 찾기에 n-1 비교를 함
- 전체 비교를 진행하므로 **시간복잡도 = 0(n<sup>2</sup>)** / 하나의 배열에서 진행하므로 **공간복잡도 = 0(n)**

### 삽입 정렬 (Insertion sort)
- 현재 위치에서, 그 이하 배열들을 비교해 자신이 들어갈 위치를 찾아 삽입하는 배열
- **최악의 경우 시간복잡도 = 0(n<sup>2</sup>)** / 이미 **정렬된 경우 시간복잡도 = 0(n)** &rarr; Big-0는 상한 기준이므로 0(n<sup>2</sup>)임
- 하나의 배열에서 진행하므로 **공간복잡도 = 0(n)**
&rarr; 선택정렬보다 빠른 연산 / 레코드 크기가 클 경우 비효율적

### 버블 정렬 (Bubble sort)
- 매번 연속된 두 인덱스를 비교해, 정한 기준의 값을 뒤로 넘겨 정렬하는 배열
- 오름차순 정렬 시, 비교마다 큰 값이 뒤로 이동해 가장 큰 값이 맨 뒤에 저장됨
- **전체 배열의 크기 - 현재까지 순환한 바퀴 수**만큼만 반복
- 전체 비교를 진행하므로 **시간복잡도 = 0(n<sup>2</sup>)** / 하나의 배열에서 진행하므로 **공간복잡도 = 0(n)**

### 합병 정렬 (Merge sort)
- 분할 정복 방식으로 설계된 알고리즘 &rarr; **분할 과정과 합병 과정이 나뉨**
- 입력으로 하나의 배열을 받고 연산 중 두개의 배열로 계속 쪼개나간 뒤 합치면서 최후에 하나의 정렬을 출력
- **합병 과정의 시간복잡도 = 0(n)** / **분할 과정의 시간복잡도 = 0(log n)** &rarr; 분할별로 합병을 진행하므로 **시간복잡도 = 0(nlog n)**
- 정렬을 위한 배열을 하나 더 생성하므로 **공간복잡도 = 0(2n)**

### 퀵 정렬 (Quick sort)
- 분할 정복 방식으로 설계된 알고리즘 &rarr; **pivot point**를 설정해 이를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식
- 분할과 동시에 정렬을 진행하므로 총 비교횟수는 nlog n, **시간복잡도 = 0(nlog n)**
- **배열이 이미 정렬된 경우가 최악의 경우임**. 이 경우 분할이 n만큼 발생해 시간복잡도가 0(n<sup>2</sup>)임
- 일반적으로 퀵정렬이 합병정렬보다 20% 이상 빠름

### 힙 정렬 (Heap sort)
- 정렬한 배열을 최소 힙으로 변환한 다음, 가장 작은 원소부터 차례대로 추출해 정렬
- **시간복잡도 = 0(nlog n)**
- 리스트 중 **일부만 정렬할 필요가 있는 경우** 유용
- 내림차순 정렬 시 최대 힙 / 오름차순 정렬 시 최소 힙

### 기수 정렬 (Radix sort)
- 어떠한 비교 연산도 실행하지 않는 독특한 정렬 기법 &rarr; LSD(least significant digit) : 가장 낮은 자릿수 / MSD(most significant digit) : 가장 높은 자릿수
       - 각 자릿수가 0~9범위라는 점에 착안해 **10개의 bucket**을 만들어 입력 데이터를 값에 따라 상자에 넣음
       - 이후 출력리스트를 만들 때 순차적으로 bucket에서 읽어옴
       - 2자리 이상의 숫자는 1의 자릿수와 10의 자릿수를 따로 사용해 정렬함
- **시간복잡도 = 0(kn), k는 4이하**
- 추가적인 메모리를 필요로 하지만 다른 방식들보다 빠름

### 계수 정렬 (Count sort)
- 데이터 크기 범위가 **제한되어 정수 형태로 표현할 수 있을 때** 사용
- **시간복잡도 = 0(n + k) &rarr; n이 k보다 클 경우 0(n)의 시간복잡도
- 정렬할 배열의 원소와 숫자를 counting해 누적시킨 후 그 값들을 정렬된 배열의 인덱스로 사용
- 가장 큰 숫자에 영향을 받으므로 최댓값에 의해 메모리 공간이 낭비될 수 있음

[sorting_detail](./Sorting.md)

---
## 분할 정복법 (Divide & Conquer)
- 전체 문제를 여러 부분 문제로 분할하고, 각 부분문제들을 해결함을 통해 전체 문제의 해답을 도출하는 전략 = Top-down approach
      - Divide : 해결할 문제를 비슷한 유형의 여러 작은 부분으로 나눔
      - Conquer : 나눈 부분 재귀적으로 해결. 문제 규모가 나눌 수 없는 단위가 되면 탈출 조건을 설정하고 해결
      - Combine : 각 부분 문제의 해답을 모아 원래 문제의 해답 도출
&rarr; 대표적으로 정렬 알고리즘 중 **퀵 정렬, 합병 정렬**과 **이진탐색, 선택 문제, 고속 푸리에 변환** 문제들이 있음
&rarr; **재귀 알고리즘을 사용하기에 오버헤드**가 발생할 수 있으며 스택에 다양한 데이터를 보관해야하므로 **스택 오버플로우**를 고려해야함

- 선택 정렬과 삽입 정렬의 최대 실행시간은 0(n<sup>2</sup>)이므로 입력 배열 크기가 크면 오랜 수행시간이 걸림
- 분할정복 알고리즘을 사용하는 합병 정렬의 실행시간은 **모든 경우에 대해 0(nlog n)으로** 비교적 빠른 시간이 걸림

